<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .code-left {
          width: 48%;
          float: left;
          clear: left;
      }

      .code-right {
          width: 48%;
          float: right;
          clear: right;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# WELCOME!

???

Intro: I'm fabien etc...
work at brandwatch
like functional shite

---

class: center, middle

# Wot r u doin?

Fabien O'Carroll talking about Functors and Monads, eventually.

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
    if (user) {
        var posts = BlogPosts.findByUser(user);
        if (posts) {
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
            if (comments) {
                return comments;
            }
            return null;
        }
        return null;
    }
    return null;
}
```

???

Give people time to read the code, check that understand what it does
Maybe mention that it is syncronous

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
*   if (user) {
        var posts = BlogPosts.findByUser(user);
*       if (posts) {
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
*           if (comments) {
                return comments;
            }
            return null;
        }
        return null;
    }
    return null;
}
```

???

Ew fucking checks all over the place

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
    if (user) {
        var posts = BlogPosts.findByUser(user);
        if (posts) {
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
            if (comments) {
                return comments;
            }
*           return null;
        }
*       return null;
    }
*   return null;
}
```

???

Yeah we explictly return, we don't have to I just prefer null as the lack of a value

What we're going to do next is find a way to remove all these checks we can't pass the values to our functions because they might throw
We need a way of doing the function, if the thing exists. So i;m going to suggest wrapping it up, with a do method

---

# Abstractions!

```javascript
function wrap(thing){
    return {
        do: function(fn) {




        }
    }
}
```

???

So heres our basic wrap function, takes a thing, returns an object with a do method

---

# Abstractions!

```javascript
function wrap(thing){
    return {
        do: function(fn) {

                                   
             
            return this;
        }
    }
}
```

???

We return this from the do method, because we're going to want to chain this (possibly)

Also note, that because we return this, each time we do a function, we'll get a wrapped thing back

---

# Abstractions!

```javascript
function wrap(thing){
    return {
        do: function(fn) {
            if (thing) {
                thing = fn(thing); 
            }
            return this;
        }
    }
}
```

???

Finally the implementation, if the thing exists, do the function to it, otherwise don't

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
    if (user) {
        var posts = BlogPosts.findByUser(user);
        if (posts) {
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
            if (comments) {
                return comments; 
            }
            return null;
        }
        return null;
    }
    return null;
}
```

???

So this is the code we had before and we want to remove the if's

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
               
        var posts = BlogPosts.findByUser(user);
        if (posts) {
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
            if (comments) {
                return comments; 
            }
            return null;
        }
        return null;
     
                
}
```

???

And again

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
               
        var posts = BlogPosts.findByUser(user);
                    
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
            if (comments) {
                return comments; 
            }
            return null;
         
                    
     
                
}
```

???

and again

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);
               
        var posts = BlogPosts.findByUser(user);
                    
            var postsIds = _.map(post => post.id, posts);
            var comments = Comments.findMany(postIds);
                           
                return comments; 
             
                        
         
                    
     
                
}
```

???

And finally

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Users.find(username);

    var posts = BlogPosts.findByUser(user);

    var postsIds = _.map(post => post.id, posts);
    var comments = Comments.findMany(postIds);

    return comments; 
}
```

???

Let's indent

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

                                              

                                                    
                                                 

                    
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Users.find(username);

    var posts = BlogPosts.findByUser(user);

    var postsIds = _.map(post => post.id, posts);
    var comments = Comments.findMany(postIds);

    return comments; 
}
```]


???

So we wrap up our user

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

                                                    
                                                 

                    
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Users.find(username);

    var posts = BlogPosts.findByUser(user);

    var postsIds = _.map(post => post.id, posts);
    var comments = Comments.findMany(postIds);

    return comments; 
}
```]


???

do the finding of blog posts 

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

                    
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Users.find(username);

    var posts = BlogPosts.findByUser(user);

    var postsIds = _.map(post => post.id, posts);
    var comments = Comments.findMany(postIds);

    return comments; 
}
```]

???

Do the getting of the posts ids and then find the comments

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments;
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Users.find(username);

    var posts = BlogPosts.findByUser(user);

    var postsIds = _.map(post => post.id, posts);
    var comments = Comments.findMany(postIds);

    return comments; 
}
```]
---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments;
}

```]

.code-right[```javascript
function getAllUsersComments(username){
    return wrap(Users.find(username))
            .do(BlogPosts.findByUser)
            .do(_.map(post => post.id))
            .do(Comments.findMany);
}
```]

???

And return the comments!

Anyone see anything wrong with this?

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

*   return comments;
}

```]

.code-right[```javascript
function getAllUsersComments(username){
    return wrap(Users.find(username))
            .do(BlogPosts.findByUser)
            .do(_.map(post => post.id))
*           .do(Comments.findMany);
}
```]

???

Right, these aren't comments any more, ballache

check everyone know ehats going on

---

# Abstractions!

```javascript
function wrap(thing){
    return {
        do: function(fn) {
            if (thing) {
                thing = fn(thing); 
            }
            return this;
        }
    }
}
```

???

Looking at our wrap function again, we need a way of getting the thing out, so we can return it

---

# Abstractions!

```javascript
function wrap(thing){
    return {
        do: function(fn) {
            if (thing) {
                thing = fn(thing); 
            }
            return this;
        },
        get: function(){
            return thing; 
        }
    }
}
```

???

So we add our simple get method

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}

```]

.code-right[```javascript
function getAllUsersComments(username){
    return wrap(Users.find(username))
            .do(BlogPosts.findByUser)
            .do(_.map(post => post.id))
            .do(Comments.findMany)
            .get();
}
```]

???

And we're fixed, the same functionality as before, but the function is much more descriptiive of what it does, win!

---

class: center, middle

# Functors

That was a functor.

???

Explain about a functor just being a wrapped value to some extend.

---

# Conventions

Although technically our `wrap` function is a Functor, there are a few changes we should make.

--

- Use a Constructor or Class

???

It can be useful when dealing with this abstractions to be able to test for instanceof
Prototype keep memory usage down

--

  - Closest thing we have to a type system

--

  - Prototype saves on memory

--

- Use an fmap method, not do

???

We use fmap to follow suite with the haskel implemenations
Interoperablity between
Can use map, but personally prefer fmap, map is a bit common place

--

  - Standard name for this method, can also be called map (can get confusing though)

--

- Return a new Functor from the fmap method, don't mutate.

???

Because why? because mutation of state causes bullshit problems

--

  - Mutation === fresh hell


---

# Mutation bug

```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}

```

---

# Mutation bug

```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return user.get();
}

```


---

# Conventions

Although technically our `wrap` function is a Functor, there are a few changes we should make.

- Use a Constructor or Class


  - Closest thing we have to a type system

  - Prototype saves on memory

- Use an fmap method, not do

  - Standard name for this method, can also be called map (can get confusing though)

- Return a new Functor from the fmap method, don't mutate.

  - Mutation === fresh hell

--

- Implement a toString method

???

Not essential, but debugging gets a hella lot easier

---

# Maybe

The wrap Functor that we created previously is one of the most well known.

- It's called the Maybe or Option Functor.

- It has two subtypes:

--

  - Just - This is the Functor that actually has a value inside.

--

  - Nothing - This, suprisingly, has nothing inside.

???

Let's implement it!

---

# Maybe

Here is a simple implementation of Maybe

```javascript
function Maybe(val){
                      
                              
            
                          
     
}

```

???

Start with an empty constructor

---

# Maybe

Here is a simple implementation of Maybe

```javascript
function Maybe(val){
    if (val != null) {
        return new Just(val); 
    }
                          
     
}

```

???

if we got a value, stick it in a Just

---

# Maybe

Here is a simple implementation of Maybe

```javascript
function Maybe(val){
    if (val != null) {
        return new Just(val); 
    } else {
        return new Nothing();    
    }
}

```

???

Otherwise stick it in nothing.

Let's start with the nothing definition

---

# Nothing

```javascript
function Nothing(){
                                   
                              
     
}

Nothing.prototype = Object.create(Maybe.prototype);

                                                     

                                                             
```

???

Start with a Constructor, and have it inherit from Maybe

---

# Nothing

```javascript
function Nothing(){
                                   
                              
     
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

                                                             
```

???

Add the fmap method, which just returns this.
remember in our do method, if the value didn't exist we just short circuited and returned this

---

# Nothing

```javascript
function Nothing(){
                                   
                              
     
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

Nothing.prototype.toString = function() { return 'Nothing'; };
```

???

Simple toString, nice to have

---

# Nothing

```javascript
function Nothing(){
    if(!(this instanceof Nothing)){
        return new Nothing(); 
    }
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

Nothing.prototype.toString = function() { return 'Nothing'; };
```

???

Finally, we do a little check in the constructor, so we don't have to use new all over the place
This making composing functors and using them as higher order fn's possible.
similar to case class in scala

LET PEOPLE READ THIS ALL

---

# Just

```javascript
function Just(val){
                                
                              
     
                         
}

Just.prototype = Object.create(Maybe.prototype);

                                    
                                     
  

                                                                                           
```

???

Blank constructor and inheritance

---

# Just

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
                         
}

Just.prototype = Object.create(Maybe.prototype);

                                    
                                     
  

                                                                                           
```

???

Chuck in that instance of check we had before

---

# Just

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

                                    
                                     
  

                                                                                           
```

???

We've got a value now, and the fmap method won't close ver it like it did in wrap

So we need to store it.

Notice this is private as FUCK

---

# Just

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
    return Maybe(fn(this.__value__));
};

                                                                                           
```

???

fmap is simple, we call the function on the value, and wrap it back up in maybe

i've seen implementations that wrap in Just - they are wrong.

fn might return null it is javascript after all :DERP:

---

# Just

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
    return Maybe(fn(this.__value__));
};

Just.prototype.toString = function() { return 'Just(' + this.__value__.toString() + ')'; };
```

???

Cute lil toString method.

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}
```]

???

Let's update this to use Maybe

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}
```]

---

# Some code

.code-left[```javascript
function getAllUsersComments(username){
    var user = wrap(Users.find(username));

    var posts = user.do(BlogPosts.findByUser);

    var postsIds = posts.do(_.map(post => post.id));
    var comments = postIds.do(Comments.findMany);

    return comments.get();
}
```]

.code-right[```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = user.fmap(BlogPosts.findByUser);

    var postsIds = posts.fmap(_.map(post => post.id));
    var comments = postIds.fmap(Comments.findMany);

    return comments.get();
}
```]

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = user.fmap(BlogPosts.findByUser);

    var postsIds = posts.fmap(_.map(post => post.id));
    var comments = postIds.fmap(Comments.findMany);

*   return comments.get();
}
```

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = user.fmap(BlogPosts.findByUser);

    var postsIds = posts.fmap(_.map(post => post.id));
    var comments = postIds.fmap(Comments.findMany);

    return comments;
}
```

---

# fmap helper fn

```javascript
function fmap(fn, functor){
    return functor.fmap(fn);
}
```

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = user.fmap(BlogPosts.findByUser);

    var postsIds = posts.fmap(_.map(post => post.id));
    var comments = postIds.fmap(Comments.findMany);

    return comments;
}
```

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = fmap(BlogPosts.findByUser, user);

    var postsIds = fmap(_.map(post => post.id), posts);
    var comments = fmap(Comments.findMany, postIds);

    return comments;
}
```
---

# fmap helper fn

```javascript
function fmap(fn, functor){
    if (!functor) {
        return function(functor){
            return functor.fmap(fn); 
        }
    }
    return functor.fmap(fn);
}
```

---

# fmap helper fn

```javascript
function fmap(fn, functor){
    if (!functor) {
        return fmap.bind(null, fn); 
    }
    return functor.fmap(fn);
}
```

---

# Some code

```javascript
var findByUser = fmap(BlogPosts.findByUser);
var mapToPostIds = fmap(_.map(post => post.id));
var findMany = fmap(Comments.findMany);

function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

---
# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

???

Back to our original code

Going to introduce another function that gets the text for comments

--
```javascript
function getCommentText(comments){
    return comment.text || comment.title || null;
}
```

???

We check for title because text might be undefined

--

```javascript
var comments = getAllUsersComments('fabien');
var commentsText = fmap(_.map(getCommentText), comments);

fmap(document.write, output);
```

???

Here we get the comments
map the commentText fn over
join them with new line characters
write them to a page

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

```javascript
function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}
```

```javascript
var comments = getAllUsersComments('fabien');
var commentsText = fmap(_.map(getCommentText), comments);

fmap(document.write, output);
```

???

Big problem here, we have nested stuff

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

```javascript
function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}
```

```javascript
var comments = getAllUsersComments('fabien');
*var commentsText = fmap(_.map(getCommentText), comments);

fmap(document.write, output);
```

???

Big problem here, we have nested stuff

---

# Nested Functor

- The return value of getAllUsersComments is Maybe([comments]);

--

- The return value of getCommentText is Maybe([text]);

--

- When we fmap getCommentText over comments we end up with Maybe(Maybe([text]));

--

- This is because getCommentText will wrap, but the fmap will wrap as well

--

- What we need is some kind of flatten operation, like with arrays.

---

class: middle center

# flatmap!

???

Let's start with Just

---

# flatmap

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
    return Maybe(fn(this.__value__));
};

Just.prototype.toString = function() { return 'Just(' + this.__value__.toString() + ')'; };
```

???

click next
here we see that Just calls the fn on the value, then wraps it in another maybe


---

# flatmap

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
*   return Maybe(fn(this.__value__));
};

Just.prototype.toString = function() { return 'Just(' + this.__value__.toString() + ')'; };
```

???

flatmap should have the same function signature

---

# flatmap

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
    return Maybe(fn(this.__value__));
};

Just.prototype.flatmap = function(fn) {

}

Just.prototype.toString = function() { return 'Just(' + this.__value__.toString() + ')'; };
```

???
we are expecting fn here to return a Maybe, so lets just call the fn, and not rewrap

---

# flatmap

```javascript
function Just(val){
    if(!(this instanceof Just)){
        return new Just(val); 
    }
    this.__value__ = val;
}

Just.prototype = Object.create(Maybe.prototype);

Just.prototype.fmap = function(fn) {
    return Maybe(fn(this.__value__));
};

Just.prototype.flatmap = function(fn) {
    return fn(this.__value__);
}

Just.prototype.toString = function() { return 'Just(' + this.__value__.toString() + ')'; };
```

???

We'll also implement it for the Nothing type

---

# flatmap

```javascript
function Nothing(){
    if(!(this instanceof Nothing)){
        return new Nothing(); 
    }
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

Nothing.prototype.toString = function() { return 'Nothing'; };
```

???

Add the blank fn

---

# flatmap

```javascript
function Nothing(){
    if(!(this instanceof Nothing)){
        return new Nothing(); 
    }
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

Nothing.prototype.flatmap = function() { };

Nothing.prototype.toString = function() { return 'Nothing'; };
```

???

This one is simple, simply return this;

---

# flatmap

```javascript
function Nothing(){
    if(!(this instanceof Nothing)){
        return new Nothing(); 
    }
}

Nothing.prototype = Object.create(Maybe.prototype);

Nothing.prototype.fmap = function() { return this; };

Nothing.prototype.flatmap = function() { return this; };

Nothing.prototype.toString = function() { return 'Nothing'; };
```

???

Also gonna creat a flatmap helper fn like the fmap one

---

# flatmap helper fn

```javascript
function flatmap(fn, functor){
    return functor.flatmap(fn);
}
```

---

# flatmap helper fn

```javascript
function flatmap(fn, functor){
    if (!functor) {
        return function(functor) {
            return functor.flatmap(fn); 
        }
    }
    return functor.flatmap(fn);
}
```

---

# flatmap helper fn

```javascript
function flatmap(fn, functor){
    if (!functor) {
        return flatmap.bind(null, fn); 
    }
    return functor.flatmap(fn);
}
```

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

```javascript
function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}
```

```javascript
var comments = getAllUsersComments('fabien');
var commentsText = fmap(_.map(getCommentText), comments);

fmap(document.write, output);
```

???

So we have to use flatmap

---

# Some code

```javascript
function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

```javascript
function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}
```

```javascript
var comments = getAllUsersComments('fabien');
var commentsText = flatmap(_.map(getCommentText), comments);

fmap(document.write, output);
```

???

Hey presto! it works!

---

# Some code

```javascript
var commentToText = flatmap(_.map(getCommentText));

function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}
```

```javascript
function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}
```

```javascript
var comments = getAllUsersComments('fabien');
var commentsText = commentToText(comments);

fmap(document.write, output);
```

---

# Monads

Monads are extentions of Functors, all the laws of Functors apply to Monads

--

Monads give us the ability to not only apply "normal" functions to the value inside, but to apply functions that return a Monad to the value inside. 

--

The wording of this can get confusing, but think back to when we had the nested Maybe, it was Monads that allowed us to get rid of that nesting.

???

Talk about how the Types of monad must be the same for flattening

For example a Promise can be a monad, and if we were to have a Promise inside of a Maybe, we can't flatten it, the Promise's value might not exist yet

---

# Promises

A Promise can be treated as both a Functor and a Monad.

Just as the the Maybe Monad contains the possibility of a value, A Promise contains a value that will exist at some point in the future from it's creation.

We use the then method to "map" functions over this value, this works as our fmap method.

If the function passed to then returns a Promise, it will automatically be flattened, so then can also be used as our flatmap method.

---

# Promises

A crude implementation of Promise as a Functor

```javascript
Promise.prototype.fmap = Promise.prototype.then;
```

--

And as a Monad

```javascript
Promise.prototype.flatmap = Promise.prototype.then;
```

---

# Some code

```javascript
var findByUser = fmap(BlogPosts.findByUser);
var mapToPostIds = fmap(_.map(post => post.id));
var findMany = fmap(Comments.findMany);
var commentToText = flatmap(_.map(getCommentText));

function getAllUsersComments(username){
    var user = Maybe(Users.find(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}

function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}

var comments = getAllUsersComments('fabien');
var commentsText = commentToText(comments);

fmap(document.write, output);
```

---

# Some code

```javascript
*var findByUser = fmap(BlogPosts.findByUserAsPromise);
var mapToPostIds = fmap(_.map(post => post.id));
*var findMany = fmap(Comments.findManyAsPromise);
var commentToText = flatmap(_.map(getCommentText));

function getAllUsersComments(username){
*   var user = Maybe(Users.findAsPromise(username));

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}

function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}

var comments = getAllUsersComments('fabien');
var commentsText = commentToText(comments);

fmap(document.write, output);
```

---

# Some code

```javascript
var findByUser = flatmap(BlogPosts.findByUserAsPromise);
var mapToPostIds = fmap(_.map(post => post.id));
var findMany = flatmap(Comments.findManyAsPromise);

function getAllUsersComments(username){
    var user = Users.findAsPromise(username);

    var posts = findByUser(user);

    var postsIds = mapToPostIds(posts);
    var comments = findMany(postIds);

    return comments;
}

function getCommentText(comment){
    return Maybe(comment.text || comment.title);
}

var comments = getAllUsersComments('fabien');
var commentsText = fmap(getCommentText, comments);

fmap(document.write, output);
```

---

# Nested Monads

We spoke before about nested monads and using flatmap to flatten them.

This only works if they're of the same type.

???

This is because if you have a promise in a maybe, you can't flatten, what if the value doesn't exist yet?

--

We're going to update our fmap helper function to deal with this.

```javascript
function fmap(fn, functor){
    if (!functor) {
        return fmap.bind(null, fn); 
    }
    return functor.fmap(fn);
}
```

---

# Nested Monads

We spoke before about nested monads and using flatmap to flatten them.

This only works if they're of the same type.


We're going to update our fmap helper function to deal with this.

```javascript
function fmap(fn, functor){
    if (!functor) {
        return fmap.bind(null, fn); 
    }
    return functor.fmap(function(value){
        return fn(value);
    });
}
```

---

# Nested Monads

We spoke before about nested monads and using flatmap to flatten them.

This only works if they're of the same type.


We're going to update our fmap helper function to deal with this.

```javascript
function fmap(fn, functor){
    if (!functor) {
        return fmap.bind(null, fn); 
    }
    return functor.fmap(function(value){
        if (value.fmap) {
            return fmap(fn, value); 
        }
        return fn(value);
    });
}
```

---

# Nested Monads

We'll also update our flatmap helper function in the same way.

```javascript
function flatmap(fn, monad){
    if (!monad) {
        return flatmap.bind(null, fn); 
    }
    return monad.flatmap(fn);
}
```

---

# Nested Monads

We'll also update our flatmap helper function in the same way.

```javascript
function flatmap(fn, monad){
    if (!monad) {
        return flatmap.bind(null, fn); 
    }
    return monad.flatmap(function(value){
        if (value.flatmap) {
        
        }
    });
}
```

---

# So Functors huh?

Wikipedia says:
> A functor is a mapping between two categories

???

What does this mean?

--

> A functor `F` that maps from "C" to "D" is a mapping that: 

>    - associates each object `X` in "C" to an object `F[X]` in "D" 

???

Explain that this might not mean anything, but will be explained in a sec
Object can be thought of as a thing, in the category of numbers, an object is 1 or 5

--

>    - associates each morphism `X -> Y` in "C" to a morphism `F[X] -> F[Y]` in "D"

???

Explain again this will be done in a sec

In the category of numbers, a morphism is + or *

---

# What do we have?

- A "category" of JavaScript values(objects*), we'll call "C"

--

- A "category" of "wrapped" values(objects*), we'll call "D"

--

- A way of associating each value(object*) in "C" with a wrapped value (`F[X]`) using the `wrap` function

--

- A way of associating each function(morphism) that acts upon values in "C" to a morphism that act's upon values in "D", the `do` method.


 
 
    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>

    <script>
        var slideshow = remark.create({
            highlightLines: true,
            ratio: '16:9'
        });
    </script>
  </body>
</html>
